* createMonster() 메서드에 대해서 테스트를 하던도중 오류를 만났다.
    오류는 총 2가지였다.
    1. body 에 아무런 값도 없던 문제 (body = )
    2. Argument(s) are different! Wanted

    해결방법
    Request 에 @EqualsAndHashCode 어노테이션을 붙여줬다.

    - @EqualsAndHashCode
            @EqualsAndHashCode 어노테이션은 equals 와 hashcode 를 자동으로 생성해주는 어노테이션 입니다.
            @ToString 어노테이션과 마찬가지로 exclude 파라미터로 필드를 제외하거나 callSuper 파라미터로 부모 객체를 생략하거나 포함할 수 있습니다.
                - equals : 두 객체의 내용이 같은지, 동등성(equality)를 비교하는 연산자입니다.
                  * 동등성 : 객체의 값이같다. 동등성은 변수가 참조하고 있는 객체의 주소가 서로 다르더라도
                            내용만 같으면 두 변수는 동등하다고 이야기 할 수 있다.(equals 연산자로 파악가능)
                - hashcode : 두 객체가 같은 객체인지, 동일성(identity)를 비교하는 연산자입니다.
                  * 동일성 : 객체의 주소가 같다. 주소값이 같기 때문에 두 변수가 있다면 같은 객체를 바라본다.(== 연산자)

    - 1 번 오류의 내용 (필수 요청 본문이 누락되었습니다.)
      url: /create-monster, message: Required request body is
      missing: public com.fc_study.monsterGrowth.dto.CreateMonsterDto$Response
      com.fc_study.monsterGrowth.controller.MMakerController.createMonster(
      com.fc_study.monsterGrowth.dto.CreateMonsterDto$Request)

    - 원인파악 과정
        - @ToString 을 사용했을때 결과값 : CreateMonsterDto.Request(id=1, monsterLevel=BABY, monsterType=FLY, statusCode=HEALTHY, ssn=96050311082045, name=애기몬스터, age=3, height=170, weight=73)
        - @ToString 을 사용하지 않았을때의 결과값 : com.fc_study.monsterGrowth.dto.CreateMonsterDto$Request@61911947
        - new ObjectMapper().writeValueAsString(getCreateRequest()) 를 사용했을때의 결과값 (Json 타입으로의 변환)
            : {"id":1,"monsterLevel":"BABY","monsterType":"FLY","statusCode":"HEALTHY","ssn":"96050311082045","name":"애기몬스터","age":3,"height":170,"weight":73}

    - 과정의 결과를 가지고 분석
      @ToString 을 사용하지 않았을때의 결과값을 보면 주소값을 참조하는 것을 볼 수 있다.
      문제는 객체의 값이 아닌 request 로 참조값을 넘겨받았기 때문에 문제가 되는것 이라고 생각한다.

    - 해결방법 (@EqualsAndHashCode(of = "id")
      @EqualsAndHashCode 어노테이션을 사용하면 동등성(equals)과 동일성(hashcode)을 자동으로 생성해준다.
      참조된 주소값이 다르더라도 내용만 같으면 동등하다고 판단해준다. 즉, 넘어온 매개변수가 주소값을 참조하고 있으나
      equals 를 이용하여 그 안의 내용물인 같은지 파악해주는 것.

    - 파라미터로 받는 값 (CreateMonsterDto.Request request)
    @PostMapping("/create-monster")
        public CreateMonsterDto.Response createMonster(
                @Valid @RequestBody final CreateMonsterDto.Request request
        ){
            log.info("Start CreateMonster !!!");
            return mMakerService.createMonster(request);
        }

    - 인자값으로 넘겨준 객체
      private CreateMonsterDto.Request getCreateRequest(){
                      return CreateMonsterDto.Request.builder()
                              .id(1L)
                              .monsterLevel(BABY)
                              .monsterType(FLY)
                              .statusCode(StatusCode.HEALTHY)
                              .ssn("96050311082045")
                              .name("애기몬스터")
                              .age(3)
                              .height(170)
                              .weight(73)
                              .build();
          }


    - 2번 오류 내용
      Argument(s) are different! Wanted:
      com.fc_study.monsterGrowth.service.MMakerService#0 bean.createMonster(
          com.fc_study.monsterGrowth.dto.CreateMonsterDto$Request@36e43829
      );
      -> at com.fc_study.monsterGrowth.controller.MMakerControllerTest.createMonster(MMakerControllerTest.java:109)
      Actual invocations have different arguments:
      com.fc_study.monsterGrowth.service.MMakerService#0 bean.createMonster(
          com.fc_study.monsterGrowth.dto.CreateMonsterDto$Request@152c4495
      );
      -> at com.fc_study.monsterGrowth.controller.MMakerControllerTest.createMonster(MMakerControllerTest.java:97)
      com.fc_study.monsterGrowth.service.MMakerService#0 bean.createMonster(
          com.fc_study.monsterGrowth.dto.CreateMonsterDto$Request@3eb292cd
      );
      -> at com.fc_study.monsterGrowth.controller.MMakerController.createMonster(MMakerController.java:26)

    - 오류 발생지
      then(mMakerService).should(times(2)).createMonster(getCreateRequest());

    - 오류 내용 분석
      Actual invocations have different arguments (실제 호출에는 다른 인수가 있습니다.)
      위의 오류를 잡고나니 같은 오류로 보인다... @EqualsAndHashCode 를 사용하면 에러가 나지
      않는다. 이 역시 내용물은 일치하나 참조값을 가지고 넘어가기 때문에 발생한 오류인걸로 파악된다.

      해결법 ArgumentMatchers.refEq() 를 사용해 해당 객체를 감싸주면 된다고 한다.
      그러나 https://javadoc.io/doc/org.mockito/mockito-core/2.8.47/org/mockito/ArgumentMatchers.html 를 보면
      Object argument that is reflection-equal to the given value with support for excluding selected fields from a class.
      This matcher can be used when equals() is not implemented on compared objects. Matcher uses java reflection API to compare fields of wanted and actual object.
      라고 되어있습니다. equals() 가 구현되지 않았을 때, 원하는 객체와 실제 객체를 비교한다고 한다.
      그럼 결론은... @EqualsAndHashCode 어노테이션을 붙여주면 됩니다.

    - @EqualsAndHashCode 주의점
      그냥 사용하면 순환참조하는 문제가 발생한다고 하니 @EqualsAndHashCode(of = "id")
      다음과 같은 방식으로 사용하면 된다고 한다. 이건 나중에 알아보도록 하자.








@Test
    @DisplayName("Monster Created Test")
    void createMonster() throws Exception{
        // TODO : create-monster 호출시 mMakerService.createMonster()을 리턴. 리턴값은 CreateMonsterDto.TestResponse
        // TODO : given(준비) = 어떠한 데이터가 준비되었을 때
        given(mMakerService.createMonster(getCreateRequest()))
                .willReturn(CreateMonsterDto.TestResponse.fromEntity(defaultMonster));

        // TODO : when(실행) = 어떠한 함수를 실행하면, andExpect : 기대하는 값이 나왔는지 체크해볼 수 있는 메소드드
        CreateMonsterDto.Response result = mMakerService.createMonster(getCreateRequest());

        // TODO : then(검증) = 어떠한 결과가 나와야 한다.
        ObjectMapper mapper = new ObjectMapper();
        mockMvc.perform(
                        post("/create-monster")
                                .contentType(contentType)
                                .content(mapper.writeValueAsString(result)))
                .andExpect(status().isOk())
                .andDo(print())
                .andReturn();
        // TODO : times() 해당 메서드가 몇번 호출되었는지 검증
        // TODO : then(Mock객체).should(수행횟수 검증).수행 메서드와(인자값)
        then(mMakerService).should(times(2)).createMonster(getCreateRequest());
    }