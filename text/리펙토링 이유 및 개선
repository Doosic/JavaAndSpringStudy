#리펙토링 꼭 해야만 하는가?

* 사실 SI 에서는 리팩토링이라는 개념이 거의 없었다...
    - 왜냐하면 SI(System Integration) -> SM(System Maintenance) 로 넘기고 끝인 경우가 많았기 때문
    - 일부 프레임워크를 만드는 팀은 제외

* IT 서비스에서는 리팩토링이 아주 중요해진 이유는?
    - 서비스 오픈 후 변화의 폭이 크다
        - 절대 바뀌지 않는다는 정책이 바뀜
            - 국내전용 -> 글로벌
            - PC 전용 -> 모바일, 앱도 지원
        - 중간에 추가적인 레이어가 하나씩 더 들어가는 경우 흔함
          A 나라의 온라인 강좌, B 나라의 오프라인 강좌.. 온라인 오프라인 둘만있던것이 온라인에서의 어떤 종류의 온라인,
          어떤 종류의 오프라인 이런식으로 추가가 될수 있다. 처음에는 3개국에서 하던것이 8개국 이런식으로 늘어나면서 정책들이 늘어날 수 가 있다.
        - 기존 구조를 뒤흔드는 기능 추가를 하는 경우가 많다.
          이런 기능을 추가하면 좋겠는데요? 하고 요구하는 경우가 일년에 한 두번씩 있다.
    - 1번의 큰 변화는 프로젝트를 최속 1.5배 이상 복잡하게 만든다
    - 이 복잡성을 줄여주는 것이 바로 리펙토링


* 리팩토링의 주요 포인트
    - 일정에 맞추느라 품질이 다소 떨어졌던 부분
    - 서비스에서 핵심적이면서 사용자 경험에 큰 영향을 끼치는 부분
    - 복잡도가 높고 향후 기능 추가, 변경 가능성이 높은 부분
    - 타 서비스에서도 활용할만한 공통적인 기능
        - 외부 라이브러리나 시스템으로 도출
    - 테스트코드 등도 가능
    - 도전적인 부분
        - 새로운 기술로 성능 향상이나 유지보수성이 향상이 가능한 부분
        - (기존도 나쁘지 않지만) 더 좋은 구성 방법이 생각나는 부분


* 개선 방법
    - DMakerController 에 getDeveloperDetail() 과 같이
      요청을 받는 값들 String memberId 는 바뀌면 안되기 때문에 final 로 지정해주어야 한다.

    - get 메서드이긴 하지만 혹시 나중에 추가적인 기능이 들어갔을 때를 대비해 Transactional 을 사용 그리고 도중에
      트랜잭션 도중에 값이 변경되지 않도록 readOnly = true 를 붙여준다.
        - Transactional 어노테이션의 기능을 제공하는 라이브러리는 2가지가 있다.
              - import javax.transaction.Transactional;
              - import org.springframework.transaction.annotation.Transactional;
              - https://willseungh0.tistory.com/75 -> 읽기전용 트랜잭션 사용시 성능향상 이유

    - 수정시 무언가의 정보를 수정한다면, 이전의 정보가 있어야한다. 그때마다
      무언가가 존재하는지를 먼저 체크해야하고, 없다면 Exception 을 던져주어야 한다.
      근데 그렇게되면 공통적인 Exception 을 던지는 코드가 늘어난다. 이런 부분을 줄여야 한다.

    - 매개변수로 들어오는 값들중 null 이 되서는 안되는 값들에 @NonNull 을 붙여줄 수 있다. if 문으로 null 체크 안해도됨.

    - 매직넘버(해당 메서드에 고정으로 박아둔 숫자, 그렇기에 해당 메서드를 찾아가야만 알 수 있다)
      상수로 지정하던지, 매개변수로 받자

    - 코딩 컨벤션 (팀원들간의 코드 스타일을 지키는것)

    - 자주 사용되는 부분을 변수로 사용하거나, 메서드로 만드는것.